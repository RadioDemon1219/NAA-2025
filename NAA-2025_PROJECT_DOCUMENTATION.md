# Документация проекта NAA-2025

## Обзор проекта

NAA-2025 - это компилятор для некоторого языка программирования, реализованный на C++. Проект состоит из нескольких этапов компиляции:

1. **Лексический анализ** - разбор исходного кода на лексемы
2. **Синтаксический анализ** - проверка грамматической правильности с использованием магазинного автомата и грамматики Грейбах
3. **Семантический анализ** - проверка семантической корректности
4. **Преобразование в польскую нотацию** - преобразование выражений для упрощения вычисления
5. **Генерация кода** - создание ассемблерного кода для архитектуры x86

## Структура проекта

Проект состоит из следующих основных компонентов:

### Основные файлы
- `NAA-2025.cpp` - главный файл программы, координирующий все этапы компиляции
- `Generator.cpp/h` - генератор кода (основной файл, который вы изучаете)

### Модули компилятора
- `Parm.cpp/h` - обработка параметров командной строки
- `In.cpp/h` - входной анализ и чтение файлов
- `Log.cpp/h` - система логирования
- `LexAnaliz.cpp/h` - лексический анализатор
- `LT.cpp/h` - таблица лексем
- `IT.cpp/h` - таблица идентификаторов
- `MFST.cpp/h` - магазинный автомат для синтаксического анализа
- `Greibah.cpp/h` - грамматика Грейбах
- `SemAnaliz.cpp/h` - семантический анализатор
- `PolishNotation.cpp/h` - преобразование в польскую нотацию
- `Error.cpp/h` - обработка ошибок

### Заголовочные файлы
- `Header.h` - общие определения
- `Graphs.h` - определения графов
- `Greibach.h` - определения грамматики Грейбах

## Подробное описание файлов

### NAA-2025.cpp - Главный файл программы

Главный файл программы, который управляет всем процессом компиляции. Основные этапы:

1. **Парсинг параметров командной строки** (`Parm::getparm`)
2. **Входной анализ** (`In::getin`) - чтение и предварительная обработка исходного файла
3. **Лексический анализ** (`Lexer::analyze`) - разбор на лексемы с построением таблиц
4. **Синтаксический анализ** (`MFST::Mfst`) - проверка грамматики с использованием магазинного автомата
5. **Семантический анализ** (`Semantic::semanticsCheck`) - проверка типов и областей видимости
6. **Преобразование в польскую нотацию** (`Polish::PolishNotation`)
7. **Генерация кода** (`Gener::CodeGeneration`) - создание ассемблерного кода

Ключевые структуры данных:
- `tables.lextable` - таблица лексем
- `tables.idtable` - таблица идентификаторов
- `greibach` - грамматика Грейбах

### Generator.cpp - Генератор кода

**Файл:** `Generator.cpp` (2197 строк)
**Назначение:** Преобразование промежуточного представления в ассемблерный код для архитектуры x86

#### Основные функции

#### `Gener::CodeGeneration(Lexer::LEX& tables, Parm::PARM& parm, Log::LOG& log, In::InWord* words)`

Главная функция генерации кода. Проходит по таблице лексем и генерирует соответствующий ассемблерный код.

**Алгоритм работы:**
1. Создает файл с ассемблерным кодом
2. Записывает заголовок программы (BEGIN)
3. Обрабатывает константы и переменные
4. Генерирует код для каждого оператора
5. Добавляет завершение программы (END)

**Ключевые макросы:**
```cpp
#define ITENTRY(x)  tables.idtable.table[tables.lextable.table[x].idxTI]
#define LEXEMA(x)   tables.lextable.table[x].lexema
```

#### `genExprCode(Lexer::LEX& tables, Log::LOG& log, int pos, int& endPos, bool isOctalContext, In::InWord* words)`

Генерирует код для арифметических и логических выражений.

**Поддерживаемые операции:**
- Арифметические: `+`, `-`, `*`, `/`, `^` (возведение в степень), `□` (квадрат)
- Сравнения: `==`, `!=`, `<`, `>`, `<=`, `>=`
- Функциональные вызовы

**Особенности:**
- Использует стек для вычисления выражений
- Поддержка восьмеричных литералов
- Обработка строковых и числовых типов

#### `genCallFuncCode(Lexer::LEX& tables, Log::LOG& log, int i)`

Генерирует код для вызова функций. Поддерживает:
- `StrLength` → `strSize`
- `StrCompare` → `strCompare`

**Алгоритм:**
1. Извлекает параметры функции из стека
2. Помещает их в регистры/на стек в соответствии с соглашением stdcall
3. Вызывает функцию
4. Обрабатывает возвращаемое значение

#### `genEqualCode(Lexer::LEX& tables, Log::LOG& log, int i)`

Генерирует код для операций присваивания (`=`).

**Поддержка типов:**
- Целые числа
- Строки
- Символы
- Логические значения

#### `getUniqueVarName(int entryIndex, const char* baseName)`

Создает уникальные имена переменных для избежания конфликтов в ассемблере.

**Алгоритм:**
- Использует карту `varNameMap` для отслеживания соответствий
- Для переменных, объявленных с `decl hex`, применяет специальные правила именования

#### `isOctalVariableInGenerator(Lexer::LEX& tables, int varIdx)`

Проверяет, является ли переменная восьмеричной (объявлена с `decl hex`).

#### Вспомогательные структуры

**Стеки для управления метками:**
```cpp
stack<string> switchEndLabels;
stack<string> nextCaseLabels;
stack<string> whileEndLabels;
stack<string> whileLoopLabels;
```

**Генератор меток:**
```cpp
string getNewLabel() {
    labelCounter++;
    stringstream ss;
    ss << "label" << labelCounter;
    return ss.str();
}
```

#### Обработка различных конструкций языка

**Условные операторы (if/else):**
- Генерирует метки для ветвей
- Использует команды условного перехода `je`, `jne` и т.д.

**Циклы (while):**
- Управление стеком меток начала и конца цикла
- Команды `jmp` для организации цикла

**Операторы ввода/вывода:**
- `output`: `call outnum`, `call outstr`, `call outchar`
- `input`: чтение в буфер с последующим преобразованием

**Переключатели (switch/case):**
- Стек меток для управления переходами между case
- Обработка `break` и `default`

#### Генерация ассемблерного кода

**Заголовок программы:**
```asm
.586
.model flat, stdcall
includelib kernel32.lib
includelib "..\\Generation\\Debug\\GenLib.lib"
ExitProcess PROTO:DWORD
.stack 4096
```

**Секции:**
- `.data` - константы и переменные
- `.code` - исполняемый код

**Внешние функции:**
```asm
outnum PROTO : DWORD
outstr PROTO : DWORD
outchar PROTO : BYTE
inputStr PROTO : DWORD
stoi PROTO : DWORD, : DWORD
append PROTO : DWORD, : BYTE, : DWORD
```

### Generator.h - Заголовочный файл генератора

**Определения макросов:**
```cpp
#define SEPSTREMP  "\n;------------------------------\n"
#define SEPSTR(x)  "\n;----------- " + string(x) + " ------------\n"

#define BEGIN ".586\n.model flat, stdcall\n" \
              "includelib kernel32.lib\n" \
              "includelib \"..\\Generation\\Debug\\GenLib.lib\"\n" \
              "ExitProcess PROTO:DWORD \n" \
              ".stack 4096\n"

#define END "main ENDP\nend main"

#define EXTERN "\n outnum PROTO : DWORD\n" \
               "\n outstr PROTO : DWORD\n" \
               "\n outchar PROTO : BYTE\n" \
               "\n inputStr PROTO : DWORD\n" \
               "\n stoi PROTO : DWORD, : DWORD\n" \
               "\n append PROTO : DWORD, : BYTE, : DWORD\n"

#define ITENTRY(x)  tables.idtable.table[tables.lextable.table[x].idxTI]
#define LEXEMA(x)   tables.lextable.table[x].lexema

#define CONST ".data\n\t\tnewline byte 13, 10, 0"
#define DATA ".data\n\t\ttemp sdword ?\n\t\tbuffer byte 256 dup(0)"
#define CODE ".code"
```

**Основная функция:**
```cpp
namespace Gener
{
    void CodeGeneration(Lexer::LEX& tables, Parm::PARM& parm, Log::LOG& log, In::InWord* words = nullptr);
};
```

### Parm.cpp/h - Обработка параметров командной строки

**Назначение:** Парсинг и валидация параметров командной строки.

**Основные определения в Parm.h:**
```cpp
#define PARM_IN         L"-in:"    // Входной файл
#define PARM_OUT        L"-out:"   // Выходной файл (ассемблерный код)
#define PARM_LOG        L"-log:"   // Лог-файл
#define PARM_TABLES     L"-tb"     // Флаг вывода таблиц в консоль
#define PARM_MAX_SIZE   300        // Максимальная длина пути
```

**Структура PARM:**
```cpp
struct PARM {
    wchar_t in[PARM_MAX_SIZE];     // Путь к входному файлу
    wchar_t out[PARM_MAX_SIZE];    // Путь к выходному файлу
    wchar_t log[PARM_MAX_SIZE];    // Путь к лог-файлу
    bool is_pring_tables = false;  // Выводить таблицы в консоль
};
```

**Главная функция `getparm(int argc, wchar_t* argv[])`:**

1. **Проверка длины параметров:** Каждый параметр не должен превышать `PARM_MAX_SIZE`
2. **Парсинг параметров:**
   - `-in:путь` - входной файл (обязательный)
   - `-out:путь` - выходной файл (по умолчанию: input.asm)
   - `-log:путь` - лог-файл (по умолчанию: input.log)
   - `-tb` - вывод таблиц в консоль
3. **Валидация:** Проверяет наличие входного файла

**Обработка ошибок:**
- Код 100: Не указан входной файл
- Код 101: Слишком длинный параметр командной строки

### In.cpp/h - Входной анализ и лексическая подготовка

**Назначение:** Чтение исходного файла и предварительная обработка текста.

**Ключевые константы:**
```cpp
#define IN_MAX_LEN_TEXT 1024*1024  // Максимальный размер текста (1MB)
#define MAX_LEN_BUFFER  2048       // Максимальная длина буфера слова
```

**Таблица классификации символов:**
```cpp
enum { T = 1024, F = 2048, I = 4096, S, Q, P, N, Q2 };
// T - текст, F - запрещенный, I - игнорируемый
// S - разделитель, Q - кавычка ", Q2 - кавычка '
// P - пробел, N - новая строка
```

**Структура IN:**
```cpp
struct IN {
    int code[256] = IN_CODE_TABLE;  // Таблица классификации символов
    int size = 0;                   // Размер текста
    int lines = 1;                  // Количество строк
    int ignor = 0;                  // Количество игнорированных символов
    unsigned char* text;            // Текст программы
    InWord* words;                  // Таблица слов
};
```

**Структура InWord:**
```cpp
struct InWord {
    char word[MAX_LEN_BUFFER];  // Слово/лексема
    int line;                   // Номер строки
    static int size;            // Общее количество слов
};
```

**Главная функция `getin(wchar_t infile[], std::ostream* stream)`:**

1. **Чтение файла:** Открывает и читает входной файл побайтно
2. **Фильтрация символов:**
   - **F (запрещенные):** Символы с кодами 0-31 (кроме табуляции, перевода строки)
   - **I (игнорируемые):** Табуляция и другие управляющие символы
   - **N (новая строка):** Увеличивает счетчик строк
   - **Остальные:** Сохраняются в текст
3. **Обработка ошибок:** Код 200 для запрещенных символов

**Функция `getWordsTable(std::ostream* stream, unsigned char* text, int* code, int textSize)`:**

Разбивает текст на слова/лексемы:

1. **Обработка разделителей (S):** `+-*/=<>!` и др.
   - Распознает составные операторы: `>=`, `<=`, `==`, `!=`
   - Обрабатывает знак минус в числах: `-123`

2. **Обработка строковых литералов (Q, Q2):**
   - Распознает строки в двойных `"` и одинарных `'` кавычках
   - Проверяет корректное закрытие кавычек
   - Ошибки: 207 (незакрытая строка), 311 (строка не закрыта перед переводом строки)

3. **Обработка пробелов (P) и новой строки (N):**что
   - Завершает текущее слово
   - Увеличивает счетчик строк

4. **Сбор слов:** Сохраняет слова в таблицу `InWord` с номером строки

### Log.cpp/h - Система логирования

**Назначение:** Запись отладочной информации, ошибок и результатов работы компилятора.

**Структура LOG:**
```cpp
struct LOG {
    wchar_t logfile[PARM_MAX_SIZE];  // Путь к лог-файлу
    std::ofstream* stream;           // Поток для записи
};
```

**Главная функция `getstream(wchar_t logfile[])`:**

1. **Конвертация пути:** Преобразует wide string в multibyte
2. **Открытие файла:** Создает поток для записи в лог-файл
3. **Обработка ошибок:** Код 103 при неудаче открытия файла

**Функция `writeLog(LOG& log)`:**
Записывает заголовок лога с текущей датой и временем.

**Функция `writeLine(std::ostream* stream, char* c, ...)`:**
Записывает форматированные строки в поток:
- Поддержка переменного количества аргументов
- Динамическое выделение памяти для конкатенации строк
- Корректная обработка кодировки Windows-1251 в консоли

**Функция `writeParm(LOG& log, Parm::PARM& parm)`:**
Записывает параметры командной строки в лог.

**Функция `writeIn(std::ostream* stream, In::IN& in)`:**
Записывает статистику входного файла:
- Количество символов
- Количество строк
- Количество проигнорированных символов

**Функция `writeError(std::ostream* stream, Error::ERROR error)`:**
Записывает информацию об ошибке в указанный поток.

**Функция `Close(LOG& log)`:**
Закрывает лог-файл и освобождает ресурсы.

### LexAnaliz.cpp/h - Лексический анализатор

**Назначение:** Преобразование последовательности слов в лексемы и построение таблиц идентификаторов и лексем.

**Ключевые определения:**
- Типы данных: `integer`, `string`, `char`, `bool`
- Ключевые слова: `decl`, `while`, `switch`, `case`, `default`, `break`, `main`, `function`, `func`, `return`, `output`, `input`, `true`, `false`
- Литералы: числовые (десятичные, шестнадцатеричные `0x`, двоичные `0b`, восьмеричные `0o`), строковые `"text"`, символьные `'c'`, логические `true`/`false`

**Главная функция `analyze(LEX& tables, In::IN& in, Log::LOG& log, Parm::PARM& parm)`:**
Преобразует массив слов `in.words` в последовательность лексем с помощью конечных автоматов (FST) и заполняет таблицы `LT` и `IT`.

### LT.cpp/h - Таблица лексем

**Назначение:** Хранение последовательности распознанных лексем.

**Ключевые константы:**
```cpp
#define LEX_SEPARATORS	 'D'	// Разделители
#define LEX_SEPARATOR	 ';'	// Точка с запятой
#define LEX_COMMA		 ','	// Запятая
#define LEX_LEFTHESIS	 '('	// Левая скобка
#define LEX_RIGHTTHESIS	 ')'	// Правая скобка
#define LEX_LBRACE       '{'    // Левая фигурная скобка
#define LEX_RBRACE       '}'    // Правая фигурная скобка

#define LEX_ID_TYPE    	 't'	// Тип данных
#define LEX_ID			 'i'	// Идентификатор
#define LEX_LITERAL		 'l'	// Литерал

#define LEX_FUNCTION     'f'	// func
#define LEX_FUNCTION_MAIN 'F'	// function main
#define LEX_MAIN		 'm'	// main
#define LEX_RETURN		 'e'	// return
#define LEX_OUTPUT		 'o'	// output
#define LEX_DECL          'Q'    // decl
#define LEX_INPUT         'I'    // input

#define LEX_WHILE         'W'    // while
#define LEX_SWITCH        'S'    // switch
#define LEX_CASE		 'C'    // case
#define LEX_DEFAULT		 'U'    // default
#define LEX_BREAK         'K'    // break

#define LEX_EQUAL		 '='	// Присваивание
#define LEX_MORE		 '>'	// Больше
#define LEX_LESS		 '<'	// Меньше
#define LEX_EQUALS		 '&'	// Равно
#define LEX_NOTEQUALS	 'N'	// Не равно
#define LEX_LTEQ         'L'    // Меньше или равно
#define LEX_GTEQ         'G'    // Больше или равно

#define LEX_INCREMENT	 'A'	// ++
#define LEX_DECREMENT	 'B'	// --
#define LEX_MULTIPLY     '*'    // Умножение
#define LEX_EXPONENT     'E'    // Возведение в степень ^
#define LEX_SQUARE       'P'    // Квадрат □

#define LEX_STRSIZE		 'X'	// StrLength/StrSize
#define LEX_STRCOMPARE	 'Y'	// StrCompare

#define LEX_LITERAL_HEX  'x'	// Шестнадцатеричный литерал
#define LEX_LITERAL_BIN  'B'	// Двоичный литерал
#define LEX_LITERAL_OCT  'O'	// Восьмеричный литерал
```

**Структура Entry:**
```cpp
struct Entry {
    char lexema;           // Код лексемы (один символ)
    int sn;                // Номер строки
    int idxTI;             // Индекс в таблице идентификаторов
    int original_word_idx; // Индекс оригинального слова для литералов
};
```

**Структура LexTable:**
```cpp
struct LexTable {
    int maxsize;    // Максимальный размер
    int size;       // Текущий размер
    Entry* table;   // Массив записей
};
```

**Основные функции:**
- `Create(int size)` - создание таблицы
- `Add(LexTable& lextable, Entry entry)` - добавление лексемы
- `writeLexTable()` - вывод таблицы в лог
- `writeLexemsOnLines()` - вывод лексем по строкам

### IT.cpp/h - Таблица идентификаторов

**Назначение:** Хранение информации об всех идентификаторах программы (переменные, функции, параметры, литералы).

**Типы идентификаторов:**
```cpp
enum IDTYPE {
    V = 1,  // Variable - переменная
    F = 2,  // Function - функция
    P = 3,  // Parameter - параметр
    L = 4,  // Literal - литерал
    S = 5   // Standard function - стандартная функция
};
```

**Типы данных:**
```cpp
enum IDDATATYPE {
    INTEGER = 1,      // Целое число (short, -32768..32767)
    SYMB = 2,         // Символ (char)
    SYMB_STRING = 3,  // Строка (массив char)
    BOOL = 4,         // Логическое значение
    UNDEF = 5         // Не определено
};
```

**Структура Entry:**
```cpp
struct Entry {
    union {
        short vint;              // Целое значение
        char vsymb;              // Символьное значение
        bool vbool;              // Логическое значение
        struct {
            int len;
            char str[STR_MAXSIZE];
        } vstr;                  // Строковое значение
        struct {
            int count;
            IDDATATYPE* types;
        } params;                // Параметры функции
    } value;

    int idxfirstLE;              // Индекс первой лексемы
    char id[SCOPED_ID_MAXSIZE];  // Идентификатор (с префиксом области)
    IDDATATYPE iddatatype;       // Тип данных
    IDTYPE idtype;               // Тип идентификатора
};
```

**Структура IdTable:**
```cpp
struct IdTable {
    int maxsize;    // Максимальный размер
    int size;       // Текущий размер
    Entry* table;   // Массив записей
};
```

**Основные функции:**
- `Create(int size)` - создание таблицы
- `Add(IdTable& idtable, Entry entry)` - добавление идентификатора
- `isId(IdTable& idtable, char id[])` - поиск идентификатора по имени
- `SetValue()` - установка значения идентификатора
- `writeIdTable()` - вывод таблицы в лог

**Стандартные функции:**
```cpp
enum STDFNC {
    F_STRSIZE,     // strSize(string) -> integer
    F_STRCOMPARE,  // strCompare(string, string) -> integer
    F_NOT_STD
};
```

## Архитектура генератора кода (Generator.cpp)

### Основные компоненты генерации кода

**Ключевые макросы:**
```cpp
#define ITENTRY(x)  tables.idtable.table[tables.lextable.table[x].idxTI]
#define LEXEMA(x)   tables.lextable.table[x].lexema
```

**Стеки для управления потоком:**
```cpp
stack<string> switchEndLabels;    // Метки конца switch
stack<string> nextCaseLabels;     // Метки следующих case
stack<string> whileEndLabels;     // Метки конца while
stack<string> whileLoopLabels;    // Метки начала while
```

### Функции генерации кода

#### 1. `CodeGeneration(Lexer::LEX& tables, Parm::PARM& parm, Log::LOG& log, In::InWord* words)`
Главная функция генерации. Проходит по таблице лексем и генерирует ассемблерный код.

#### 2. `genExprCode(Lexer::LEX& tables, Log::LOG& log, int pos, int& endPos, bool isOctalContext, In::InWord* words)`
Генерирует код для выражений. Поддерживает:
- Арифметические операции: +, -, *, /, ^, □
- Логические операции: ==, !=, <, >, <=, >=
- Вызовы функций
- Работа со стеком для вычисления

#### 3. `genEqualCode(Lexer::LEX& tables, Log::LOG& log, int i)`
Генерирует код присваивания (=).

#### 4. `genCallFuncCode(Lexer::LEX& tables, Log::LOG& log, int i)`
Генерирует код вызова функций с передачей параметров.

#### 5. `getUniqueVarName(int entryIndex, const char* baseName)`
Создает уникальные имена переменных для ассемблера.

### Генерация ассемблерного кода

**Заголовок программы:**
```asm
.586
.model flat, stdcall
includelib kernel32.lib
includelib "..\\Generation\\Debug\\GenLib.lib"
ExitProcess PROTO:DWORD
.stack 4096
```

**Внешние функции:**
```asm
outnum PROTO : DWORD     ; Вывод числа
outstr PROTO : DWORD     ; Вывод строки
outchar PROTO : BYTE     ; Вывод символа
inputStr PROTO : DWORD   ; Ввод строки
stoi PROTO : DWORD, : DWORD  ; Преобразование строки в число
append PROTO : DWORD, : BYTE, : DWORD  ; Конкатенация строк
```

### Обработка конструкций языка

**Условные операторы:**
- `if/else` - генерация меток и условных переходов
- Использование `je`, `jne`, `jg`, `jl`, `jle`, `jge`

**Циклы:**
- `while` - управление стеком меток начала и конца цикла
- Команды `jmp` для организации цикла

**Переключатели:**
- `switch/case/default` - стек меток для переходов между case
- Обработка `break`

**Ввод/вывод:**
- `output` - вызов функций `outnum`, `outstr`, `outchar`
- `input` - чтение в буфер с преобразованием типов

## Система ошибок (Error.cpp/h)

Компилятор имеет развитую систему обработки ошибок с кодами:
- 100: Не указан входной файл
- 101: Слишком длинный параметр или файл
- 102: Ошибка открытия файла
- 103: Ошибка создания лог-файла
- 200: Недопустимый символ во входном файле
- 207: Незакрытая строковая константа
- 213: Неопознанная лексема
- 304: Переменная объявлена вне функции
- 600: Отсутствует функция main

## Заключение

Проект NAA-2025 представляет собой полнофункциональный компилятор с полным циклом обработки:
лексический анализ → синтаксический анализ → семантический анализ → генерация кода.

**Ключевые особенности:**
1. **Модульная архитектура** - каждый этап компиляции выделен в отдельный модуль
2. **Использование конечных автоматов** - для лексического анализа
3. **Магазинный автомат** - для синтаксического анализа с грамматикой Грейбах
4. **Генерация ассемблерного кода** - для архитектуры x86 с поддержкой основных конструкций языка
5. **Обработка областей видимости** - с уникальными именами идентификаторов
6. **Расширенная система логирования** - для отладки и анализа процесса компиляции

**Рекомендации по работе с кодом:**
1. Изучите `NAA-2025.cpp` для понимания общего потока
2. Разберитесь с таблицами `LT` и `IT` - они являются центральными структурами данных
3. Изучите `Generator.cpp` - наиболее сложный модуль, отвечающий за генерацию кода
4. Используйте логи для отладки - в них записывается подробная информация о каждом этапе
5. Ознакомьтесь с грамматикой Грейбах в `Greibah.cpp` для понимания синтаксиса языка

Теперь вы можете самостоятельно работать с проектом, понимая назначение каждого компонента и их взаимодействие.


